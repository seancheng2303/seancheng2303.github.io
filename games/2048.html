<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2048 — Grid Fix</title>
<style>
  :root{
    --cell-size:100px;
    --gap:20px;
    --cells:4;
  }
  body{
    margin:0; min-height:100vh; display:flex; flex-direction:column; align-items:center; justify-content:center;
    background:#faf8ef; font-family:system-ui, -apple-system, "Noto Sans TC", Arial;
  }
  #header{
    width: var(--w);
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:20px;
  }
  #score{
    background:#bbada0;
    color:#fff;
    padding:10px 20px;
    border-radius:8px;
    font-size:20px;
    font-weight:700;
  }
  #restart{
    background:#8f7a66;
    color:#fff;
    padding:10px 20px;
    border:none;
    border-radius:8px;
    font-size:16px;
    font-weight:600;
    cursor:pointer;
  }
  #restart:hover{ background:#9f8a76; }

  #game{
    --w: calc((var(--cell-size) * var(--cells)) + (var(--gap) * (var(--cells) + 1)));
    width: var(--w);
    height: var(--w);
    background: #bbada0;
    border-radius:12px;
    position:relative;
    box-shadow: 0 8px 24px rgba(0,0,0,.12);
    user-select:none;
  }
  .grid{
    position:absolute; inset:0; padding: var(--gap);
    display:grid;
    grid-template-columns: repeat(var(--cells), var(--cell-size));
    grid-template-rows: repeat(var(--cells), var(--cell-size));
    gap: var(--gap);
    pointer-events:none;
  }
  .cell{
    background:#cdc0b4;
    border-radius:8px;
  }
  .tiles{
    position:absolute;
    inset: var(--gap);
    pointer-events:none;
  }
  .tile{
    position:absolute;
    width: var(--cell-size); height: var(--cell-size);
    display:grid; place-items:center;
    border-radius:8px;
    font-weight:800; font-size:28px;
    color:#776e65;
    transform: translate(var(--x,0px), var(--y,0px));
    transition: transform 180ms cubic-bezier(.22,.9,.36,1), box-shadow 120ms;
    box-shadow: 0 6px 12px rgba(0,0,0,.08);
    user-select:none;
  }
  .tile.new{ animation: pop 180ms ease-out; }
  @keyframes pop{
    0% { transform: translate(var(--x,0px), var(--y,0px)) scale(0.5); }
    80% { transform: translate(var(--x,0px), var(--y,0px)) scale(1.08); }
    100% { transform: translate(var(--x,0px), var(--y,0px)) scale(1); }
  }
  .tile.merged{ animation: merge 200ms ease-out; z-index: 20; }
  @keyframes merge{
    0% { transform: translate(var(--x,0px), var(--y,0px)) scale(1); }
    50% { transform: translate(var(--x,0px), var(--y,0px)) scale(1.25); box-shadow:0 0 14px #f9a620; }
    100% { transform: translate(var(--x,0px), var(--y,0px)) scale(1); }
  }
  .v2{ background:#eee4da }
  .v4{ background:#ede0c8 }
  .v8{ background:#f2b179; color: #f9f6f2 }
  .v16{ background:#f59563; color:#f9f6f2 }
  .v32{ background:#f67c5f; color:#f9f6f2 }
  .v64{ background:#f65e3b; color:#f9f6f2 }
  .v128{ background:#edcf72; color:#f9f6f2 }
  .v256{ background:#edcc61; color:#f9f6f2 }
  .v512{ background:#edc850; color:#f9f6f2 }
  .v1024{ background:#edc53f; color:#f9f6f2 }
  .v2048{ background:#edc22e; color:#f9f6f2 }
  @media (max-width:480px){
    :root{ --cell-size:72px; --gap:12px; }
    .tile{ font-size:20px; }
    #score{ font-size:16px; padding:8px 12px; }
    #restart{ font-size:14px; padding:8px 12px; }
  }
</style>
</head>
<body>
  <div id="header">
    <div id="score">分數：0</div>
    <button id="restart">重新開始</button>
  </div>
  <div id="game"></div>

<script>
(function(){
  const ROOT = document.documentElement;
  const CELL_SIZE = parseFloat(getComputedStyle(ROOT).getPropertyValue('--cell-size')) || 100;
  const GAP = parseFloat(getComputedStyle(ROOT).getPropertyValue('--gap')) || 20;
  const SIZE = parseInt(getComputedStyle(ROOT).getPropertyValue('--cells')) || 4;

  const game = document.getElementById('game');
  const scoreEl = document.getElementById('score');
  const restartBtn = document.getElementById('restart');

  const gridEl = document.createElement('div'); gridEl.className = 'grid';
  for(let i=0;i<SIZE*SIZE;i++) gridEl.appendChild(document.createElement('div')).className='cell';
  const tilesLayer = document.createElement('div'); tilesLayer.className='tiles';
  game.appendChild(gridEl); game.appendChild(tilesLayer);

  let board = [], nextId = 0, score = 0;

  function createEmpty(){ return Array.from({length:SIZE}, ()=>Array.from({length:SIZE}, ()=>0)); }

  function addRandomTile(){
    const empties=[];
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(board[r][c]===0) empties.push([r,c]);
    if(!empties.length) return;
    const [r,c] = empties[(Math.random()*empties.length)|0];
    const value = Math.random() < 0.1 ? 4 : 2;
    board[r][c] = { value, id: nextId++, new: true };
  }

  function updateScore(add){
    score += add;
    scoreEl.textContent = "分數：" + score;
  }

  function init(){
    board = createEmpty();
    nextId = 0;
    score = 0;
    updateScore(0);
    addRandomTile(); addRandomTile();
    render();
  }

  function slideAndMergeLine(line){
    const tiles = line.filter(x=>x!==0);
    const result = [];
    for(let i=0;i<tiles.length;i++){
      if(i+1<tiles.length && tiles[i].value === tiles[i+1].value){
        const newVal = tiles[i].value * 2;
        updateScore(newVal);
        result.push({ value: newVal, id: tiles[i].id, merged: true });
        i++;
      }else{
        result.push(Object.assign({}, tiles[i]));
      }
    }
    while(result.length < SIZE) result.push(0);
    return result;
  }

  function move(dir){
    let moved=false;
    if(dir==='left' || dir==='right'){
      for(let r=0;r<SIZE;r++){
        const row = board[r].slice();
        const iter = (dir==='left') ? row : row.slice().reverse();
        const merged = slideAndMergeLine(iter);
        const newRow = (dir==='left') ? merged : merged.slice().reverse();
        for(let c=0;c<SIZE;c++){
          const a = board[r][c], b = newRow[c];
          if(!equalCell(a,b)) moved = true;
          board[r][c] = b===0?0:b;
        }
      }
    }else{
      for(let c=0;c<SIZE;c++){
        const col=[];
        for(let r=0;r<SIZE;r++) col.push(board[r][c]);
        const iter = (dir==='up') ? col : col.slice().reverse();
        const merged = slideAndMergeLine(iter);
        const newCol = (dir==='up') ? merged : merged.slice().reverse();
        for(let r=0;r<SIZE;r++){
          const a = board[r][c], b = newCol[r];
          if(!equalCell(a,b)) moved = true;
          board[r][c] = b===0?0:b;
        }
      }
    }
    if(moved){ addRandomTile(); render(); }
  }

  function equalCell(a,b){
    if(a===0 && b===0) return true;
    if((a===0)!==(b===0)) return false;
    return a.value===b.value && a.id===b.id;
  }

  function render(){
    const cellSize = CELL_SIZE, gap = GAP;
    const existing = new Map();
    tilesLayer.querySelectorAll('.tile').forEach(el=> existing.set(el.dataset.id, el));
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const cell = board[r][c];
        if(!cell) continue;
        const key = String(cell.id);
        let tile = existing.get(key);
        if(!tile){
          tile = document.createElement('div');
          tile.className = `tile v${cell.value} new`;
          tile.textContent = cell.value;
          tile.dataset.id = key;
          tile.style.setProperty('--x', `${c * (cellSize + gap)}px`);
          tile.style.setProperty('--y', `${r * (cellSize + gap)}px`);
          tilesLayer.appendChild(tile);
          requestAnimationFrame(()=> tile.classList.remove('new'));
          if(cell.new) delete cell.new;
        }else{
          tile.className = `tile v${cell.value}`;
          tile.textContent = cell.value;
          if(cell.merged){
            tile.classList.add('merged');
            tile.addEventListener('animationend', ()=> tile.classList.remove('merged'), { once: true });
            delete cell.merged;
          }
          tile.style.setProperty('--x', `${c * (cellSize + gap)}px`);
          tile.style.setProperty('--y', `${r * (cellSize + gap)}px`);
        }
        existing.delete(key);
      }
    }
    existing.forEach(el => el.remove());
  }

  window.addEventListener('keydown', e=>{
    const k = e.key.toLowerCase();
    if(['arrowup','w','arrowdown','s','arrowleft','a','arrowright','d'].includes(k)){
      e.preventDefault();
      const dir = (k==='arrowup'||k==='w')?'up':(k==='arrowdown'||k==='s')?'down':(k==='arrowleft'||k==='a')?'left':'right';
      move(dir);
    }
  }, { passive:false });

  restartBtn.addEventListener('click', init);

  init();
})();
</script>
</body>
</html>
